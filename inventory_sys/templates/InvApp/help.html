
def product_history(request, product_id):

    product = Product.objects.get(product_id=product_id)
    
    product_batches = ProductBatch.objects.filter(product=product).select_related('product', 'supplier').order_by('-stock_date')
    
    for batch in product_batches:
        activities = []
        for order in Order.objects.filter(batch_sku=batch.batch_sku).select_related('customer'):
            activities.append({
                'date': order.order_date,
                'activity_type': 'Order',
                'quantity': -order.quantity, 
                'reference': f"Order #{order.id}",
                'user': order.customer or {'username': 'System'}
            })
        # Adjustments
        for adj in StockAdjustment.objects.filter(batch=batch).select_related('user'):
            activities.append({
                'date': adj.created_at,
                'activity_type': adj.get_adjustment_type_display(),
                'quantity': adj.quantity if adj.adjustment_type == 'add' else -adj.quantity,
                'reference': adj.reason,
                'user': adj.user or {'username': 'System'}
            })
        # Batch receipt
        activities.append({
            'date': batch.stock_date,
            'activity_type': 'Received',
            'quantity': batch.initial_quantity,
            'reference': 'Batch Receipt',
            'user': {'username': 'System'}
        })
        activities.sort(key=lambda x: x['date'], reverse=True)
        batch.activities = activities
    
    # Combined activity
    combined_activity = []
    for batch in product_batches:
        combined_activity.append({
            'date': batch.stock_date,
            'event_type': 'batch',
            'description': f"Batch {batch.batch_sku} added with {batch.initial_quantity} {product.units}",
            'quantity': batch.initial_quantity,
            'customer': {'name': 'System'}
        })
    
    orders = Order.objects.filter(product=product).select_related('batch', 'customer').order_by('-order_date')
    for order in orders:
        combined_activity.append({
            'date': order.order_date,
            'event_type': 'order',
            'description': f"Order #{order.id} placed for {order.quantity} {product.units}" + (f" from batch {order.batch.batch_sku}" if order.batch else ""),
            'quantity': order.quantity,
            'customer': order.customer or {'name': 'System'}
        })
    
    adjustments = StockAdjustment.objects.filter(product=product).select_related('batch', 'user').order_by('-created_at')
    for adj in adjustments:
        combined_activity.append({
            'date': adj.created_at.date(),
            'event_type': 'adjustment',
            'description': f"Stock {adj.adjustment_type} of {adj.quantity} {product.units} ({adj.reason})" + (f" for batch {adj.batch.batch_sku}" if adj.batch else ""),
            'quantity': adj.quantity if adj.adjustment_type == 'add' else -adj.quantity,
            'customer': adj.user or {'name': 'System'}
        })
    
    # Sort by date descending
    combined_activity.sort(key=lambda x: x['date'], reverse=True)
    
    # Paginate combined activity
    activity_paginator = Paginator(combined_activity, 10)
    activity_page = request.GET.get('page', 1)
    combined_activity = activity_paginator.get_page(activity_page)
    
    # Paginate orders
    orders_paginator = Paginator(orders, 10)
    orders_page = request.GET.get('page', 1)
    orders = orders_paginator.get_page(orders_page)
    
    # Paginate adjustments
    adjustments_paginator = Paginator(adjustments, 10)
    adjustments_page = request.GET.get('page', 1)
    adjustments = adjustments_paginator.get_page(adjustments_page)
    
    # Sales data for last 12 months
    today = datetime.now().date()
    sales_labels = []
    sales_data = []
    for i in range(11, -1, -1):
        month_start = (today - relativedelta(months=i)).replace(day=1)
        month_end = (month_start + relativedelta(months=1)) - timedelta(days=1)
        sales_labels.append(month_start.strftime("%b %Y"))
        monthly_sales = Order.objects.filter(
            product=product,
            order_date__gte=month_start,
            order_date__lte=month_end
        ).aggregate(total=Sum('quantity'))['total'] or 0
        sales_data.append(monthly_sales)
    
    # Batch data for charts
    batch_labels = [f"Batch {batch.batch_sku}" for batch in product_batches]
    batch_quantities = [batch.current_quantity for batch in product_batches]
    
    # Product metrics
    thirty_days_ago = today - timedelta(days=30)
    total_sold_last_30_days = Order.objects.filter(
        product=product, order_date__gte=thirty_days_ago
    ).aggregate(total=Sum('quantity'))['total'] or 0
    
    yearly_sales = Order.objects.filter(
        product=product, order_date__gte=today - timedelta(days=365)
    ).aggregate(total=Sum('quantity'))['total'] or 0
    avg_monthly_sales = yearly_sales / 12 if yearly_sales else 0
    
    suggested_reorder_quantity = product.reorder_level * 2 if product.reorder_level else 0
    
    expiring_batches_count = product_batches.filter(
        expiry_date__lte=today + timedelta(days=30),
        expiry_date__gte=today
    ).count()
    
    context = {
        'product': product,
        'product_batches': product_batches,  # Added for Batch History tab
        'combined_activity': combined_activity,
        'orders': orders,
        'adjustments': adjustments,
        'total_sold_last_30_days': total_sold_last_30_days,
        'avg_monthly_sales': avg_monthly_sales,
        'suggested_reorder_quantity': suggested_reorder_quantity,
        'expiring_batches_count': expiring_batches_count,
        'sales_labels': sales_labels,
        'sales_data': sales_data,
        'batch_labels': batch_labels,
        'batch_quantities': batch_quantities,
        'active_tab': request.GET.get('tab', 'activity'),
    }
    
    return render(request, 'InvApp/product_history.html', context)



    
def product_history(request, product_id):
product = get_object_or_404(Product, pk=product_id)

combined_activity = []

for batch in product.productbatch_set.all():

    combined_activity.append({
        'date': batch.stock_date,
        'event_type': 'batch',
        'description': f"Batch {batch.batch_sku} added with {batch.initial_quantity} {product.units}",
        'quantity': batch.initial_quantity
    })

    orders = product.order_set.all().order_by('-order_date')

for order in orders:
    combined_activity.append({
        'date': order.order_date,
        'event_type': 'order',
        'user': order.customer,
        'quantity': order.quantity
    })

adjustments = product.stockadjustment_set.all().order_by('-created_at')

for adj in adjustments:
    combined_activity.append({
        'date': adj.created_at.date(),
        'event_type': 'adjustment',
        'description': f"Stock adjustment: {adj.quantity} {product.units} ({adj.reason})",
        'quantity': adj.quantity
    })

 # Sort by date descending
combined_activity.sort(key=lambda x: x['date'], reverse=True)

paginator = Paginator(combined_activity, 10)
page_number = request.GET.get('page')
page_obj = paginator.get_page(page_number)

today = datetime.now()
sales_labels = []
sales_data = []

for i in range(11, -1, -1):
 month = today - relativedelta(months=i)
 sales_labels.append(month.strftime("%b %Y"))
 sales_data.append(0) 

batch_labels = [f"Batch {batch.batch_sku}" for batch in product.productbatch_set.all()]
batch_quantities = [batch.current_quantity for batch in product.productbatch_set.all()]

context = {
    'product': product,
    'combined_activity': page_obj,
    'orders': orders,
    'adjustments': adjustments,
    'sales_labels': sales_labels,
    'sales_data': sales_data,
    'batch_labels': batch_labels,
    'batch_quantities' : batch_quantities,
}

return render(request, 'InvApp/product_history.html', context)

# def get_sales_data(request):
#     orders = (
#         Order.objects
#         .values('order_date__month', 'order_date__year')
#         .annotate(total_quantity=Sum('quantity'))
#         .order_by('order_date__year', 'order_date__month')
#     )

#     labels = [order['order_date__year'] * 100 + order['order_date__month'] for order in orders]
#     labels = [datetime(year=year // 100, month=year % 100, day=1).strftime('%b %Y') for year in labels]
#     data = [order['total_quantity'] for order in orders]

#     return JsonResponse({'labels': labels, 'data': data})





# def stock_adjustments(request):
#     selected_date = request.GET.get('date', datetime.today().strftime('%Y-%m-%d'))

#     if request.method == 'POST':
#         product_id = request.POST.get('product_id')
#         adjustment_type = request.POST.get('adjustment_type')
#         quantity = request.POST.get('quantity')
#         reason = request.POST.get('reason')
#         batch_id = request.POST.get('batch_sku')

#         try:
#             product = Product.objects.get(product_id=product_id)
#         except Product.DoesNotExist:
#             messages.error(request, "Product not found.")
#             return redirect('stock_adjustments')

#         if not quantity or not quantity.isdigit() or int(quantity) <= 0:
#             messages.error(request, "Invalid quantity. Please enter a positive number.")
#             return redirect('stock_adjustments')
#         quantity = int(quantity)

#         if adjustment_type not in ['add', 'subtract']:
#             messages.error(request, "Invalid adjustment type.")
#             return redirect('stock_adjustments')

#         try:
#             product = Product.objects.get(product_id=product_id)
#         except Product.DoesNotExist:
#             messages.error(request, "Invalid product ID.")
#             return redirect('stock_adjustments')

#         batch = None
#         if batch_id:
#             try:
#                 batch = ProductBatch.objects.get(id=batch_id, product=product)
#                 if adjustment_type == 'add':
#                     batch.current_quantity = F('current_quantity') + quantity
#                     batch.save()
#                     product.quantity_in_stock = F('quantity_in_stock') + quantity
#                     product.save()
#                 elif adjustment_type == 'subtract':
#                     if batch.current_quantity >= quantity:
#                         batch.current_quantity = F('current_quantity') - quantity
#                         batch.save()
#                         product.quantity_in_stock = F('quantity_in_stock') - quantity
#                         product.save()
#                     else:
#                         messages.error(request, "Insufficient stock in selected batch to subtract.")
#                         return redirect('stock_adjustments')
#             except ProductBatch.DoesNotExist:
#                 messages.error(request, "Invalid Batch ID.")
#                 return redirect('stock_adjustments')

#         StockAdjustment.objects.create(
#             product=product,
#             adjustment_type=adjustment_type,
#             quantity=quantity,
#             reason=reason,
#             batch=batch,
#             created_at=timezone.now()
#         )
#         messages.success(request, "Stock adjusted successfully!")
#         return redirect('stock_adjustments')

#     else:
#         products = Product.objects.all()
#         product_batches = ProductBatch.objects.all()
#         stock_adjustments_qs = StockAdjustment.objects.all().select_related('product')

#         start_date = request.GET.get('start_date')
#         end_date = request.GET.get('end_date')

#         if start_date and end_date:
#             try:
#                 start_date = datetime.strptime(start_date, "%Y-%m-%d").date()
#                 end_date = datetime.strptime(end_date, "%Y-%m-%d").date()
#                 stock_adjustments_qs = stock_adjustments_qs.filter(
#                     created_at__date__range=(start_date, end_date)
#                 )
#             except ValueError:
#                 messages.error(request, "Invalid date format. Please use YYYY-MM-DD.")
#                 return redirect('stock_adjustments')
#         else:
#             today = datetime.today().date()
#             stock_adjustments_qs = stock_adjustments_qs.filter(created_at__date=today)
#             start_date = end_date = today

#         context = {
#             'stock_adjustments_list': stock_adjustments_qs,
#             'selected_date': selected_date,
#             'products': products,
#             'product_batches': product_batches,
#             'start_date': start_date,
#             'end_date': end_date,
#         }

#         return render(request, 'InvApp/adjust.html', context)




def stock_view(request):
    start_date = request.GET.get('startDate', str(date.today()))
    end_date = request.GET.get('endDate', str(date.today()))
    
    try:
        start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
    except ValueError:
        start_date = date.today()
        end_date = date.today()

    if start_date > end_date:
        start_date, end_date = end_date, start_date

    stocks = Stock.objects.filter(
        stock_date__range=[start_date, end_date]
    ).select_related('product', 'product__category').order_by('-stock_date')
    
    products = Product.objects.all().select_related('category')
    categories = Category.objects.all()
    suppliers = Supplier.objects.all()

    paginator = Paginator(stocks, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    def get_stock_alerts():
        alerts = []
        critical_stocks = Stock.objects.filter(
            total_stock__lte=F('product__reorder_level') * Decimal('0.2')
        ).select_related('product')
        
        low_stocks = Stock.objects.filter(
            total_stock__lte=F('product__reorder_level'),
            total_stock__gt=F('product__reorder_level') * Decimal('0.2')
        ).select_related('product')
        
        for stock in critical_stocks:
            alerts.append({
                'product': stock.product,
                'current_stock': stock.total_stock,
                'status': 'critical'
            })
            
        for stock in low_stocks:
            alerts.append({
                'product': stock.product,
                'current_stock': stock.total_stock,
                'status': 'low'
            })
            
        return alerts

    stock_alerts = get_stock_alerts()

    top_products = Stock.objects.values(
        'product__name'
    ).annotate(
        total=Sum('total_stock')
    ).order_by('-total')[:10]
    
    category_dist = Stock.objects.values(
        'product__category__name'
    ).annotate(
        count=Count('id'),
        total_stock=Sum('total_stock')
    ).order_by('-count')

    def annotate_batch_status(queryset):
        today = date.today()
        for batch in queryset:
            if batch.expiry_date:
                days_left = (batch.expiry_date - today).days
                if days_left < 0:
                    batch.expiry_status = 'expired'
                elif days_left <= 30:
                    batch.expiry_status = 'expiring-soon'
                else:
                    batch.expiry_status = 'good'
                batch.days_until_expiry = days_left
            else:
                batch.expiry_status = None
                batch.days_until_expiry = None
        return queryset

    product_batches = annotate_batch_status(ProductBatch.objects.all().select_related('product', 'supplier'))

    total_products = Product.objects.count()
    low_stock_items = len([a for a in stock_alerts if a['status'] == 'low'])
    critical_stock_items = len([a for a in stock_alerts if a['status'] == 'critical'])
    
    total_stock_value = sum(
        stock.total_stock * stock.product.selling_price 
        for stock in Stock.objects.select_related('product')
    )

    # CHANGE 5: Updated context to include start_date and end_date
    context = {
        'stocks': page_obj,
        'products': products,
        'categories': categories,
        'suppliers': suppliers,
        'start_date': start_date,
        'end_date': end_date,
        'page_obj': page_obj,
        'product_batches': product_batches,
        'stock_alerts': stock_alerts,
        'total_products': total_products,
        'low_stock_items': low_stock_items,
        'critical_stock_items': critical_stock_items,
        'total_stock_value': total_stock_value,
        'product_names': [p['product__name'] for p in top_products],
        'stock_levels': [p['total'] for p in top_products],
        'category_names': [c['product__category__name'] for c in category_dist],
        'category_counts': [c['count'] for c in category_dist],
        'category_stock': [c['total_stock'] for c in category_dist],
    }
    
    return render(request, 'InvApp/stock.html', context)


    def export_dashboard_csv(request, table_type):
    def export_dashboard_csv(request, table_type):
    start_date = request.GET.get('start_date', (timezone.now().date() - timedelta(days=30)).strftime('%Y-%m-%d'))
    end_date = request.GET.get('end_date', timezone.now().date().strftime('%Y-%m-%d'))
    category_id = request.GET.get('category')
    customer_id = request.GET.get('customer')
    search_query = request.GET.get('search', '')
    

    try:
        start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
    except ValueError:
        start_date = timezone.now().date() - timedelta(days=30)
        end_date = timezone.now().date()

    response = HttpResponse(content_type='text/csv')
    if table_type == 'orders':
        response['Content-Disposition'] = f'attachment; filename="recent_orders_{start_date}_to_{end_date}.csv"'
        orders = Order.objects.filter(order_date__range=[start_date, end_date]).select_related('customer', 'product', 'batch_sku')
        
        # Apply filters
        if category_id:
            orders = orders.filter(product__category_id=category_id)
        if customer_id:
            orders = orders.filter(customer_id=customer_id)
        if search_query:
            orders = orders.filter(
                Q(customer__name__icontains=search_query) |
                Q(product__name__icontains=search_query) |
                Q(id__icontains=search_query)
            )

        # Check if orders exist
        if not orders.exists():
            messages.warning(request, "No orders found for the selected filters.")
            return HttpResponse(status=204)  # No content

        writer = csv.writer(response)
        writer.writerow([
            'Order ID', 'Customer', 'Product', 'Batch SKU', 'Quantity', 'Units',
            'Price per Unit', 'Total Price', 'Payment Method', 'Discount (%)',
            'Final Total', 'Order Date', 'Status'
        ])
        for order in orders:
            writer.writerow([
                order.id,
                order.customer.name,
                order.product.name,
                order.batch_sku.batch_sku if order.batch_sku else 'N/A',
                order.quantity,
                order.units,
                order.price_per_unit,
                order.total_price,
                order.payment_method,
                order.discount,
                order.final_total,
                order.order_date,
                order.status
            ])
        messages.success(request, "Orders exported successfully.")
    elif table_type == 'low_stock':
        response['Content-Disposition'] = f'attachment; filename="low_stock_items_{start_date}_to_{end_date}.csv"'
        low_stock_items = Product.objects.annotate(
            critical_level=F('reorder_level') * 0.2
        ).filter(quantity_in_stock__lt=F('reorder_level'))
        if category_id:
            low_stock_items = low_stock_items.filter(category_id=category_id)
        if search_query:
            low_stock_items = low_stock_items.filter(name__icontains=search_query)
        
        if not low_stock_items.exists():
            messages.warning(request, "No low stock items found for the selected filters.")
            return HttpResponse(status=204)

        writer = csv.writer(response)
        writer.writerow(['Product', 'Category', 'Current Stock', 'Reorder Level'])
        for item in low_stock_items:
            writer.writerow([
                item.name,
                item.category.name,
                item.quantity_in_stock,
                item.reorder_level
            ])
        messages.success(request, "Low stock items exported successfully.")
    else:
        messages.error(request, "Invalid export type.")
        return HttpResponse(status=400)

    return response 



    
def export_orders_csv(request):
    selected_date = request.GET.get('orderDate', timezone.now().date().strftime('%Y-%m-%d'))
    try:
        selected_date = datetime.strptime(selected_date, '%Y-%m-%d').date()
    except ValueError:
        selected_date = timezone.now().date()

    orders = Order.objects.filter(order_date=selected_date).select_related('customer', 'product', 'batch_sku')

    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="orders_{selected_date}.csv"'

    writer = csv.writer(response)
    writer.writerow([
        'Order ID', 'Customer', 'Product', 'Batch SKU', 'Quantity', 'Units',
        'Price per Unit', 'Total Price', 'Payment Method', 'Discount (%)',
        'Final Total', 'Order Date', 'Status'
    ])

    for order in orders:
        writer.writerow([
            order.id,
            order.customer.name,
            order.product.name,
            order.batch_sku.batch_sku if order.batch_sku else 'N/A',
            order.quantity,
            order.units,
            order.price_per_unit,
            order.total_price,
            order.payment_method,
            order.discount,
            order.final_total,
            order.order_date,
            order.status
        ])

    return response 


    
# def order_page(request: HttpRequest) -> HttpResponse:
#     """
#     View to display stock information with filters and alerts.
#     """
#     start_date, end_date = parse_date_range(request)

#     orders = Order.objects.select_related('customer', 'product', 'batch_sku').filter(
#         order_date__range=[start_date, end_date]
#     )

#     # Filters
#     customer_id = request.GET.get('customer')
#     status = request.GET.get('status')
#     payment_method = request.GET.get('payment_method')
#     search_query = request.GET.get('search', '')
#     sort_by = request.GET.get('sort_by', '-order_date')
#     page_size = int(request.GET.get('page_size', 10))

#     if customer_id:
#         orders = orders.filter(customer_id=customer_id)

#     if status:
#         orders = orders.filter(status=status)

#     if payment_method:
#         orders = orders.filter(payment_method=payment_method)

#     if search_query:
#         orders = orders.filter(
#             Q(customer__name__icontains=search_query) |
#             Q(product__name__icontains=search_query) |
#             Q(id__icontains=search_query)
#         )

#     orders = orders.order_by(sort_by)

#     total_customers = orders.values('customer').distinct().count()
#     total_orders = orders.count()
#     total_quantity = orders.aggregate(total=Sum('quantity'))['total'] or 0
#     total_cash_made = orders.aggregate(total=Sum('final_total'))['total'] or 0.0

#     paginator = Paginator(orders, page_size)
#     page_number = request.GET.get('page')
#     page_obj = paginator.get_page(page_number)

#     context = {
#         'orders': page_obj,
#         'page_obj': page_obj,
#         'start_date': start_date,
#         'end_date': end_date,
#         'total_customers': total_customers,
#         'total_orders': total_orders,
#         'total_quantity': total_quantity,
#         'total_cash_made': total_cash_made,
#         'customers': Customer.objects.all(),
#         'products': Product.objects.all(),
#         'product_batches': ProductBatch.objects.all(),
#         'status_choices': ['pending', 'completed', 'cancelled'],
#         'payment_methods': ['cash', 'credit_card', 'mobile_money', 'bank_transfer'],
#         'page_sizes': [10, 25, 50, 100],
#         'current_page_size': page_size,
#         'search_query': search_query,
#         'sort_by': sort_by,
#     }
#     return render(request, 'InvApp/order_page.html', context)

def place_order(request):
    if request.method == 'POST':
        customer_id = request.POST.get('orderCustomer')
        products = request.POST.getlist('products[]')
        order_quantities = request.POST.getlist('orderQuantity[]')
        units = request.POST.getlist('units[]')
        price_per_units = request.POST.getlist('price_per_unit[]')
        total_prices = request.POST.getlist('totalPrice[]')
        batch_ids = request.POST.getlist('batch_sku[]')
        discounts = request.POST.getlist('productDiscount[]')
        order_date = request.POST.get('orderDate', date.today())
        final_total = request.POST.get('finalTotal', 0)

        try:
            customer = Customer.objects.get(id=customer_id)
        except Customer.DoesNotExist:
            messages.error(request, "Selected customer does not exist.")
            return redirect('order_page')

        payment_method = request.POST.get('paymentMethod', 'cash')
        errors = []

        for i in range(len(products)):
            try:
                product_id = products[i]
                unit_id = units[i]
                batch_id = batch_ids[i]

                try:
                    unit_price = float(price_per_units[i] or 0.0)
                    total_price = float(total_prices[i] or 0.0)
                    quantity = int(order_quantities[i] or 0)
                    discount = float(discounts[i] or 0.0)
                except (ValueError, TypeError):
                    errors.append(f"Invalid input for product {product_id}.")
                    continue

                try:
                    product = Product.objects.get(product_id=product_id)
                except Product.DoesNotExist:
                    errors.append(f"Product with ID {product_id} does not exist.")
                    continue

                try:
                    batch = ProductBatch.objects.get(id=batch_id)
                except ProductBatch.DoesNotExist:
                    errors.append(f"Batch with ID {batch_id} does not exist.")
                    batch = None

                if quantity <= 0:
                    errors.append(f"Invalid quantity for product {product.name}.")
                    continue

                if product.quantity_in_stock < quantity:
                    errors.append(f"Insufficient stock for product {product.name}. Available: {product.quantity_in_stock}, Requested: {quantity}")
                    continue

                if batch and batch.current_quantity < quantity:
                    errors.append(f"Insufficient quantity in batch {batch.batch_sku}. Available: {batch.current_quantity}, Requested: {quantity}")
                    continue

                # Create Order
                Order.objects.create(
                    customer=customer,
                    product=product,
                    batch_sku=batch,
                    quantity=quantity,
                    price_per_unit=unit_price,
                    total_price=total_price,
                    units=unit_id,
                    payment_method=payment_method,
                    discount=discount,
                    order_date=order_date,
                    final_total=final_total,
                )

                # Update stock
                product.quantity_in_stock -= quantity
                product.save()

                if batch:
                    batch.current_quantity -= quantity
                    batch.save()

            except Exception as e:
                errors.append(f"Error processing product {product_id}: {str(e)}")
                continue
        if errors:
            for error in errors:
                messages.error(request, error)
            return redirect('order_page')

        messages.success(request, "Order placed successfully!")
        return redirect('order_page')

    return redirect('order_page')



    
logger = logging.getLogger(__name__)
class BulkUpdateOrdersView(View):
    def post(self, request):
        order_ids = request.POST.getlist('order_ids')
        action = request.POST.get('action')
        
        if not order_ids:
            messages.error(request, 'No orders selected.')
            return redirect('order_page')
        
        if action == 'update_status':
            new_status = request.POST.get('new_status')
            if not new_status:
                messages.error(request, 'No status selected.')
                return redirect('order_page')
            
            updated_count = Order.objects.filter(id__in=order_ids).update(status=new_status)
            messages.success(request, f'Updated status for {updated_count} order(s) to {dict(Order.STATUS_CHOICES).get(new_status, new_status)}.')
        
        elif action == 'delete':
            orders_to_delete = Order.objects.filter(id__in=order_ids).select_related('product')
            
            for order in orders_to_delete:
                product = order.product
                product.quantity_in_stock = F('quantity_in_stock') + order.quantity
                product.save()
            
            deleted_count, _ = orders_to_delete.delete()
            messages.success(request, f'Successfully deleted {deleted_count} order(s).')
        
        else:
            messages.error(request, 'Invalid action selected.')
        
        return redirect('order_page')

