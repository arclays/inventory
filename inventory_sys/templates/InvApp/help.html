
def product_history(request, product_id):

    product = Product.objects.get(product_id=product_id)
    
    product_batches = ProductBatch.objects.filter(product=product).select_related('product', 'supplier').order_by('-stock_date')
    
    for batch in product_batches:
        activities = []
        for order in Order.objects.filter(batch_sku=batch.batch_sku).select_related('customer'):
            activities.append({
                'date': order.order_date,
                'activity_type': 'Order',
                'quantity': -order.quantity, 
                'reference': f"Order #{order.id}",
                'user': order.customer or {'username': 'System'}
            })
        # Adjustments
        for adj in StockAdjustment.objects.filter(batch=batch).select_related('user'):
            activities.append({
                'date': adj.created_at,
                'activity_type': adj.get_adjustment_type_display(),
                'quantity': adj.quantity if adj.adjustment_type == 'add' else -adj.quantity,
                'reference': adj.reason,
                'user': adj.user or {'username': 'System'}
            })
        # Batch receipt
        activities.append({
            'date': batch.stock_date,
            'activity_type': 'Received',
            'quantity': batch.initial_quantity,
            'reference': 'Batch Receipt',
            'user': {'username': 'System'}
        })
        activities.sort(key=lambda x: x['date'], reverse=True)
        batch.activities = activities
    
    # Combined activity
    combined_activity = []
    for batch in product_batches:
        combined_activity.append({
            'date': batch.stock_date,
            'event_type': 'batch',
            'description': f"Batch {batch.batch_sku} added with {batch.initial_quantity} {product.units}",
            'quantity': batch.initial_quantity,
            'customer': {'name': 'System'}
        })
    
    orders = Order.objects.filter(product=product).select_related('batch', 'customer').order_by('-order_date')
    for order in orders:
        combined_activity.append({
            'date': order.order_date,
            'event_type': 'order',
            'description': f"Order #{order.id} placed for {order.quantity} {product.units}" + (f" from batch {order.batch.batch_sku}" if order.batch else ""),
            'quantity': order.quantity,
            'customer': order.customer or {'name': 'System'}
        })
    
    adjustments = StockAdjustment.objects.filter(product=product).select_related('batch', 'user').order_by('-created_at')
    for adj in adjustments:
        combined_activity.append({
            'date': adj.created_at.date(),
            'event_type': 'adjustment',
            'description': f"Stock {adj.adjustment_type} of {adj.quantity} {product.units} ({adj.reason})" + (f" for batch {adj.batch.batch_sku}" if adj.batch else ""),
            'quantity': adj.quantity if adj.adjustment_type == 'add' else -adj.quantity,
            'customer': adj.user or {'name': 'System'}
        })
    
    # Sort by date descending
    combined_activity.sort(key=lambda x: x['date'], reverse=True)
    
    # Paginate combined activity
    activity_paginator = Paginator(combined_activity, 10)
    activity_page = request.GET.get('page', 1)
    combined_activity = activity_paginator.get_page(activity_page)
    
    # Paginate orders
    orders_paginator = Paginator(orders, 10)
    orders_page = request.GET.get('page', 1)
    orders = orders_paginator.get_page(orders_page)
    
    # Paginate adjustments
    adjustments_paginator = Paginator(adjustments, 10)
    adjustments_page = request.GET.get('page', 1)
    adjustments = adjustments_paginator.get_page(adjustments_page)
    
    # Sales data for last 12 months
    today = datetime.now().date()
    sales_labels = []
    sales_data = []
    for i in range(11, -1, -1):
        month_start = (today - relativedelta(months=i)).replace(day=1)
        month_end = (month_start + relativedelta(months=1)) - timedelta(days=1)
        sales_labels.append(month_start.strftime("%b %Y"))
        monthly_sales = Order.objects.filter(
            product=product,
            order_date__gte=month_start,
            order_date__lte=month_end
        ).aggregate(total=Sum('quantity'))['total'] or 0
        sales_data.append(monthly_sales)
    
    # Batch data for charts
    batch_labels = [f"Batch {batch.batch_sku}" for batch in product_batches]
    batch_quantities = [batch.current_quantity for batch in product_batches]
    
    # Product metrics
    thirty_days_ago = today - timedelta(days=30)
    total_sold_last_30_days = Order.objects.filter(
        product=product, order_date__gte=thirty_days_ago
    ).aggregate(total=Sum('quantity'))['total'] or 0
    
    yearly_sales = Order.objects.filter(
        product=product, order_date__gte=today - timedelta(days=365)
    ).aggregate(total=Sum('quantity'))['total'] or 0
    avg_monthly_sales = yearly_sales / 12 if yearly_sales else 0
    
    suggested_reorder_quantity = product.reorder_level * 2 if product.reorder_level else 0
    
    expiring_batches_count = product_batches.filter(
        expiry_date__lte=today + timedelta(days=30),
        expiry_date__gte=today
    ).count()
    
    context = {
        'product': product,
        'product_batches': product_batches,  # Added for Batch History tab
        'combined_activity': combined_activity,
        'orders': orders,
        'adjustments': adjustments,
        'total_sold_last_30_days': total_sold_last_30_days,
        'avg_monthly_sales': avg_monthly_sales,
        'suggested_reorder_quantity': suggested_reorder_quantity,
        'expiring_batches_count': expiring_batches_count,
        'sales_labels': sales_labels,
        'sales_data': sales_data,
        'batch_labels': batch_labels,
        'batch_quantities': batch_quantities,
        'active_tab': request.GET.get('tab', 'activity'),
    }
    
    return render(request, 'InvApp/product_history.html', context)



    
def product_history(request, product_id):
product = get_object_or_404(Product, pk=product_id)

combined_activity = []

for batch in product.productbatch_set.all():

    combined_activity.append({
        'date': batch.stock_date,
        'event_type': 'batch',
        'description': f"Batch {batch.batch_sku} added with {batch.initial_quantity} {product.units}",
        'quantity': batch.initial_quantity
    })

    orders = product.order_set.all().order_by('-order_date')

for order in orders:
    combined_activity.append({
        'date': order.order_date,
        'event_type': 'order',
        'user': order.customer,
        'quantity': order.quantity
    })

adjustments = product.stockadjustment_set.all().order_by('-created_at')

for adj in adjustments:
    combined_activity.append({
        'date': adj.created_at.date(),
        'event_type': 'adjustment',
        'description': f"Stock adjustment: {adj.quantity} {product.units} ({adj.reason})",
        'quantity': adj.quantity
    })

 # Sort by date descending
combined_activity.sort(key=lambda x: x['date'], reverse=True)

paginator = Paginator(combined_activity, 10)
page_number = request.GET.get('page')
page_obj = paginator.get_page(page_number)

today = datetime.now()
sales_labels = []
sales_data = []

for i in range(11, -1, -1):
 month = today - relativedelta(months=i)
 sales_labels.append(month.strftime("%b %Y"))
 sales_data.append(0) 

batch_labels = [f"Batch {batch.batch_sku}" for batch in product.productbatch_set.all()]
batch_quantities = [batch.current_quantity for batch in product.productbatch_set.all()]

context = {
    'product': product,
    'combined_activity': page_obj,
    'orders': orders,
    'adjustments': adjustments,
    'sales_labels': sales_labels,
    'sales_data': sales_data,
    'batch_labels': batch_labels,
    'batch_quantities' : batch_quantities,
}

return render(request, 'InvApp/product_history.html', context)

# def get_sales_data(request):
#     orders = (
#         Order.objects
#         .values('order_date__month', 'order_date__year')
#         .annotate(total_quantity=Sum('quantity'))
#         .order_by('order_date__year', 'order_date__month')
#     )

#     labels = [order['order_date__year'] * 100 + order['order_date__month'] for order in orders]
#     labels = [datetime(year=year // 100, month=year % 100, day=1).strftime('%b %Y') for year in labels]
#     data = [order['total_quantity'] for order in orders]

#     return JsonResponse({'labels': labels, 'data': data})





# def stock_adjustments(request):
#     selected_date = request.GET.get('date', datetime.today().strftime('%Y-%m-%d'))

#     if request.method == 'POST':
#         product_id = request.POST.get('product_id')
#         adjustment_type = request.POST.get('adjustment_type')
#         quantity = request.POST.get('quantity')
#         reason = request.POST.get('reason')
#         batch_id = request.POST.get('batch_sku')

#         try:
#             product = Product.objects.get(product_id=product_id)
#         except Product.DoesNotExist:
#             messages.error(request, "Product not found.")
#             return redirect('stock_adjustments')

#         if not quantity or not quantity.isdigit() or int(quantity) <= 0:
#             messages.error(request, "Invalid quantity. Please enter a positive number.")
#             return redirect('stock_adjustments')
#         quantity = int(quantity)

#         if adjustment_type not in ['add', 'subtract']:
#             messages.error(request, "Invalid adjustment type.")
#             return redirect('stock_adjustments')

#         try:
#             product = Product.objects.get(product_id=product_id)
#         except Product.DoesNotExist:
#             messages.error(request, "Invalid product ID.")
#             return redirect('stock_adjustments')

#         batch = None
#         if batch_id:
#             try:
#                 batch = ProductBatch.objects.get(id=batch_id, product=product)
#                 if adjustment_type == 'add':
#                     batch.current_quantity = F('current_quantity') + quantity
#                     batch.save()
#                     product.quantity_in_stock = F('quantity_in_stock') + quantity
#                     product.save()
#                 elif adjustment_type == 'subtract':
#                     if batch.current_quantity >= quantity:
#                         batch.current_quantity = F('current_quantity') - quantity
#                         batch.save()
#                         product.quantity_in_stock = F('quantity_in_stock') - quantity
#                         product.save()
#                     else:
#                         messages.error(request, "Insufficient stock in selected batch to subtract.")
#                         return redirect('stock_adjustments')
#             except ProductBatch.DoesNotExist:
#                 messages.error(request, "Invalid Batch ID.")
#                 return redirect('stock_adjustments')

#         StockAdjustment.objects.create(
#             product=product,
#             adjustment_type=adjustment_type,
#             quantity=quantity,
#             reason=reason,
#             batch=batch,
#             created_at=timezone.now()
#         )
#         messages.success(request, "Stock adjusted successfully!")
#         return redirect('stock_adjustments')

#     else:
#         products = Product.objects.all()
#         product_batches = ProductBatch.objects.all()
#         stock_adjustments_qs = StockAdjustment.objects.all().select_related('product')

#         start_date = request.GET.get('start_date')
#         end_date = request.GET.get('end_date')

#         if start_date and end_date:
#             try:
#                 start_date = datetime.strptime(start_date, "%Y-%m-%d").date()
#                 end_date = datetime.strptime(end_date, "%Y-%m-%d").date()
#                 stock_adjustments_qs = stock_adjustments_qs.filter(
#                     created_at__date__range=(start_date, end_date)
#                 )
#             except ValueError:
#                 messages.error(request, "Invalid date format. Please use YYYY-MM-DD.")
#                 return redirect('stock_adjustments')
#         else:
#             today = datetime.today().date()
#             stock_adjustments_qs = stock_adjustments_qs.filter(created_at__date=today)
#             start_date = end_date = today

#         context = {
#             'stock_adjustments_list': stock_adjustments_qs,
#             'selected_date': selected_date,
#             'products': products,
#             'product_batches': product_batches,
#             'start_date': start_date,
#             'end_date': end_date,
#         }

#         return render(request, 'InvApp/adjust.html', context)




def stock_view(request):
    start_date = request.GET.get('startDate', str(date.today()))
    end_date = request.GET.get('endDate', str(date.today()))
    
    try:
        start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
    except ValueError:
        start_date = date.today()
        end_date = date.today()

    if start_date > end_date:
        start_date, end_date = end_date, start_date

    stocks = Stock.objects.filter(
        stock_date__range=[start_date, end_date]
    ).select_related('product', 'product__category').order_by('-stock_date')
    
    products = Product.objects.all().select_related('category')
    categories = Category.objects.all()
    suppliers = Supplier.objects.all()

    paginator = Paginator(stocks, 10)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    def get_stock_alerts():
        alerts = []
        critical_stocks = Stock.objects.filter(
            total_stock__lte=F('product__reorder_level') * Decimal('0.2')
        ).select_related('product')
        
        low_stocks = Stock.objects.filter(
            total_stock__lte=F('product__reorder_level'),
            total_stock__gt=F('product__reorder_level') * Decimal('0.2')
        ).select_related('product')
        
        for stock in critical_stocks:
            alerts.append({
                'product': stock.product,
                'current_stock': stock.total_stock,
                'status': 'critical'
            })
            
        for stock in low_stocks:
            alerts.append({
                'product': stock.product,
                'current_stock': stock.total_stock,
                'status': 'low'
            })
            
        return alerts

    stock_alerts = get_stock_alerts()

    top_products = Stock.objects.values(
        'product__name'
    ).annotate(
        total=Sum('total_stock')
    ).order_by('-total')[:10]
    
    category_dist = Stock.objects.values(
        'product__category__name'
    ).annotate(
        count=Count('id'),
        total_stock=Sum('total_stock')
    ).order_by('-count')

    def annotate_batch_status(queryset):
        today = date.today()
        for batch in queryset:
            if batch.expiry_date:
                days_left = (batch.expiry_date - today).days
                if days_left < 0:
                    batch.expiry_status = 'expired'
                elif days_left <= 30:
                    batch.expiry_status = 'expiring-soon'
                else:
                    batch.expiry_status = 'good'
                batch.days_until_expiry = days_left
            else:
                batch.expiry_status = None
                batch.days_until_expiry = None
        return queryset

    product_batches = annotate_batch_status(ProductBatch.objects.all().select_related('product', 'supplier'))

    total_products = Product.objects.count()
    low_stock_items = len([a for a in stock_alerts if a['status'] == 'low'])
    critical_stock_items = len([a for a in stock_alerts if a['status'] == 'critical'])
    
    total_stock_value = sum(
        stock.total_stock * stock.product.selling_price 
        for stock in Stock.objects.select_related('product')
    )

    # CHANGE 5: Updated context to include start_date and end_date
    context = {
        'stocks': page_obj,
        'products': products,
        'categories': categories,
        'suppliers': suppliers,
        'start_date': start_date,
        'end_date': end_date,
        'page_obj': page_obj,
        'product_batches': product_batches,
        'stock_alerts': stock_alerts,
        'total_products': total_products,
        'low_stock_items': low_stock_items,
        'critical_stock_items': critical_stock_items,
        'total_stock_value': total_stock_value,
        'product_names': [p['product__name'] for p in top_products],
        'stock_levels': [p['total'] for p in top_products],
        'category_names': [c['product__category__name'] for c in category_dist],
        'category_counts': [c['count'] for c in category_dist],
        'category_stock': [c['total_stock'] for c in category_dist],
    }
    
    return render(request, 'InvApp/stock.html', context)


    def export_dashboard_csv(request, table_type):
    def export_dashboard_csv(request, table_type):
    start_date = request.GET.get('start_date', (timezone.now().date() - timedelta(days=30)).strftime('%Y-%m-%d'))
    end_date = request.GET.get('end_date', timezone.now().date().strftime('%Y-%m-%d'))
    category_id = request.GET.get('category')
    customer_id = request.GET.get('customer')
    search_query = request.GET.get('search', '')
    

    try:
        start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
        end_date = datetime.strptime(end_date, '%Y-%m-%d').date()
    except ValueError:
        start_date = timezone.now().date() - timedelta(days=30)
        end_date = timezone.now().date()

    response = HttpResponse(content_type='text/csv')
    if table_type == 'orders':
        response['Content-Disposition'] = f'attachment; filename="recent_orders_{start_date}_to_{end_date}.csv"'
        orders = Order.objects.filter(order_date__range=[start_date, end_date]).select_related('customer', 'product', 'batch_sku')
        
        # Apply filters
        if category_id:
            orders = orders.filter(product__category_id=category_id)
        if customer_id:
            orders = orders.filter(customer_id=customer_id)
        if search_query:
            orders = orders.filter(
                Q(customer__name__icontains=search_query) |
                Q(product__name__icontains=search_query) |
                Q(id__icontains=search_query)
            )

        # Check if orders exist
        if not orders.exists():
            messages.warning(request, "No orders found for the selected filters.")
            return HttpResponse(status=204)  # No content

        writer = csv.writer(response)
        writer.writerow([
            'Order ID', 'Customer', 'Product', 'Batch SKU', 'Quantity', 'Units',
            'Price per Unit', 'Total Price', 'Payment Method', 'Discount (%)',
            'Final Total', 'Order Date', 'Status'
        ])
        for order in orders:
            writer.writerow([
                order.id,
                order.customer.name,
                order.product.name,
                order.batch_sku.batch_sku if order.batch_sku else 'N/A',
                order.quantity,
                order.units,
                order.price_per_unit,
                order.total_price,
                order.payment_method,
                order.discount,
                order.final_total,
                order.order_date,
                order.status
            ])
        messages.success(request, "Orders exported successfully.")
    elif table_type == 'low_stock':
        response['Content-Disposition'] = f'attachment; filename="low_stock_items_{start_date}_to_{end_date}.csv"'
        low_stock_items = Product.objects.annotate(
            critical_level=F('reorder_level') * 0.2
        ).filter(quantity_in_stock__lt=F('reorder_level'))
        if category_id:
            low_stock_items = low_stock_items.filter(category_id=category_id)
        if search_query:
            low_stock_items = low_stock_items.filter(name__icontains=search_query)
        
        if not low_stock_items.exists():
            messages.warning(request, "No low stock items found for the selected filters.")
            return HttpResponse(status=204)

        writer = csv.writer(response)
        writer.writerow(['Product', 'Category', 'Current Stock', 'Reorder Level'])
        for item in low_stock_items:
            writer.writerow([
                item.name,
                item.category.name,
                item.quantity_in_stock,
                item.reorder_level
            ])
        messages.success(request, "Low stock items exported successfully.")
    else:
        messages.error(request, "Invalid export type.")
        return HttpResponse(status=400)

    return response 



    
def export_orders_csv(request):
    selected_date = request.GET.get('orderDate', timezone.now().date().strftime('%Y-%m-%d'))
    try:
        selected_date = datetime.strptime(selected_date, '%Y-%m-%d').date()
    except ValueError:
        selected_date = timezone.now().date()

    orders = Order.objects.filter(order_date=selected_date).select_related('customer', 'product', 'batch_sku')

    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="orders_{selected_date}.csv"'

    writer = csv.writer(response)
    writer.writerow([
        'Order ID', 'Customer', 'Product', 'Batch SKU', 'Quantity', 'Units',
        'Price per Unit', 'Total Price', 'Payment Method', 'Discount (%)',
        'Final Total', 'Order Date', 'Status'
    ])

    for order in orders:
        writer.writerow([
            order.id,
            order.customer.name,
            order.product.name,
            order.batch_sku.batch_sku if order.batch_sku else 'N/A',
            order.quantity,
            order.units,
            order.price_per_unit,
            order.total_price,
            order.payment_method,
            order.discount,
            order.final_total,
            order.order_date,
            order.status
        ])

    return response 


    
# def order_page(request: HttpRequest) -> HttpResponse:
#     """
#     View to display stock information with filters and alerts.
#     """
#     start_date, end_date = parse_date_range(request)

#     orders = Order.objects.select_related('customer', 'product', 'batch_sku').filter(
#         order_date__range=[start_date, end_date]
#     )

#     # Filters
#     customer_id = request.GET.get('customer')
#     status = request.GET.get('status')
#     payment_method = request.GET.get('payment_method')
#     search_query = request.GET.get('search', '')
#     sort_by = request.GET.get('sort_by', '-order_date')
#     page_size = int(request.GET.get('page_size', 10))

#     if customer_id:
#         orders = orders.filter(customer_id=customer_id)

#     if status:
#         orders = orders.filter(status=status)

#     if payment_method:
#         orders = orders.filter(payment_method=payment_method)

#     if search_query:
#         orders = orders.filter(
#             Q(customer__name__icontains=search_query) |
#             Q(product__name__icontains=search_query) |
#             Q(id__icontains=search_query)
#         )

#     orders = orders.order_by(sort_by)

#     total_customers = orders.values('customer').distinct().count()
#     total_orders = orders.count()
#     total_quantity = orders.aggregate(total=Sum('quantity'))['total'] or 0
#     total_cash_made = orders.aggregate(total=Sum('final_total'))['total'] or 0.0

#     paginator = Paginator(orders, page_size)
#     page_number = request.GET.get('page')
#     page_obj = paginator.get_page(page_number)

#     context = {
#         'orders': page_obj,
#         'page_obj': page_obj,
#         'start_date': start_date,
#         'end_date': end_date,
#         'total_customers': total_customers,
#         'total_orders': total_orders,
#         'total_quantity': total_quantity,
#         'total_cash_made': total_cash_made,
#         'customers': Customer.objects.all(),
#         'products': Product.objects.all(),
#         'product_batches': ProductBatch.objects.all(),
#         'status_choices': ['pending', 'completed', 'cancelled'],
#         'payment_methods': ['cash', 'credit_card', 'mobile_money', 'bank_transfer'],
#         'page_sizes': [10, 25, 50, 100],
#         'current_page_size': page_size,
#         'search_query': search_query,
#         'sort_by': sort_by,
#     }
#     return render(request, 'InvApp/order_page.html', context)

def place_order(request):
    if request.method == 'POST':
        customer_id = request.POST.get('orderCustomer')
        products = request.POST.getlist('products[]')
        order_quantities = request.POST.getlist('orderQuantity[]')
        units = request.POST.getlist('units[]')
        price_per_units = request.POST.getlist('price_per_unit[]')
        total_prices = request.POST.getlist('totalPrice[]')
        batch_ids = request.POST.getlist('batch_sku[]')
        discounts = request.POST.getlist('productDiscount[]')
        order_date = request.POST.get('orderDate', date.today())
        final_total = request.POST.get('finalTotal', 0)

        try:
            customer = Customer.objects.get(id=customer_id)
        except Customer.DoesNotExist:
            messages.error(request, "Selected customer does not exist.")
            return redirect('order_page')

        payment_method = request.POST.get('paymentMethod', 'cash')
        errors = []

        for i in range(len(products)):
            try:
                product_id = products[i]
                unit_id = units[i]
                batch_id = batch_ids[i]

                try:
                    unit_price = float(price_per_units[i] or 0.0)
                    total_price = float(total_prices[i] or 0.0)
                    quantity = int(order_quantities[i] or 0)
                    discount = float(discounts[i] or 0.0)
                except (ValueError, TypeError):
                    errors.append(f"Invalid input for product {product_id}.")
                    continue

                try:
                    product = Product.objects.get(product_id=product_id)
                except Product.DoesNotExist:
                    errors.append(f"Product with ID {product_id} does not exist.")
                    continue

                try:
                    batch = ProductBatch.objects.get(id=batch_id)
                except ProductBatch.DoesNotExist:
                    errors.append(f"Batch with ID {batch_id} does not exist.")
                    batch = None

                if quantity <= 0:
                    errors.append(f"Invalid quantity for product {product.name}.")
                    continue

                if product.quantity_in_stock < quantity:
                    errors.append(f"Insufficient stock for product {product.name}. Available: {product.quantity_in_stock}, Requested: {quantity}")
                    continue

                if batch and batch.current_quantity < quantity:
                    errors.append(f"Insufficient quantity in batch {batch.batch_sku}. Available: {batch.current_quantity}, Requested: {quantity}")
                    continue

                # Create Order
                Order.objects.create(
                    customer=customer,
                    product=product,
                    batch_sku=batch,
                    quantity=quantity,
                    price_per_unit=unit_price,
                    total_price=total_price,
                    units=unit_id,
                    payment_method=payment_method,
                    discount=discount,
                    order_date=order_date,
                    final_total=final_total,
                )

                # Update stock
                product.quantity_in_stock -= quantity
                product.save()

                if batch:
                    batch.current_quantity -= quantity
                    batch.save()

            except Exception as e:
                errors.append(f"Error processing product {product_id}: {str(e)}")
                continue
        if errors:
            for error in errors:
                messages.error(request, error)
            return redirect('order_page')

        messages.success(request, "Order placed successfully!")
        return redirect('order_page')

    return redirect('order_page')



    
logger = logging.getLogger(__name__)
class BulkUpdateOrdersView(View):
    def post(self, request):
        order_ids = request.POST.getlist('order_ids')
        action = request.POST.get('action')
        
        if not order_ids:
            messages.error(request, 'No orders selected.')
            return redirect('order_page')
        
        if action == 'update_status':
            new_status = request.POST.get('new_status')
            if not new_status:
                messages.error(request, 'No status selected.')
                return redirect('order_page')
            
            updated_count = Order.objects.filter(id__in=order_ids).update(status=new_status)
            messages.success(request, f'Updated status for {updated_count} order(s) to {dict(Order.STATUS_CHOICES).get(new_status, new_status)}.')
        
        elif action == 'delete':
            orders_to_delete = Order.objects.filter(id__in=order_ids).select_related('product')
            
            for order in orders_to_delete:
                product = order.product
                product.quantity_in_stock = F('quantity_in_stock') + order.quantity
                product.save()
            
            deleted_count, _ = orders_to_delete.delete()
            messages.success(request, f'Successfully deleted {deleted_count} order(s).')
        
        else:
            messages.error(request, 'Invalid action selected.')
        
        return redirect('order_page')



logger = logging.getLogger(__name__)

def get_latest_buying_price_subquery():
    latest_batch = ProductBatch.objects.filter(product=OuterRef('product')).order_by('-stock_date')[:1]
    return Subquery(latest_batch.values('buying_price')[:1], output_field=FloatField())

def calculate_batch_values():
    return ProductBatch.objects.values(
        'product__name', 'product__product_id', 'product__category__name'
    ).annotate(
        buying_price=Sum(F('buying_price')),
        quantity=Sum('initial_quantity'),
        total_value=Sum(
            ExpressionWrapper(
                F('initial_quantity') * F('buying_price'),
                output_field=FloatField()
            )
        ),
    ).order_by('-total_value')

def calculate_total_inventory_value(batch_values):
    return sum(item['total_value'] for item in batch_values if item['total_value']) or 0.0

def process_inventory_data(batch_values, total_inventory_value):
    return [
        {
            'name': item['product__name'],
            'sku': item['product__product_id'],
            'quantity_in_stock': item['quantity'],
            'unit_cost': item['buying_price'],
            'total_value': item['total_value'],
            'percentage': round((item['total_value'] / total_inventory_value) * 100, 2) if total_inventory_value else 0,
            'category__name': item['product__category__name']
        }
        for item in batch_values
    ]

def get_low_stock_items():
    critical_threshold = 0.2
    return Product.objects.annotate(
        critical_level=F('reorder_level') * critical_threshold
    ).filter(quantity_in_stock__lt=F('reorder_level')).values(
        'product_id', 'name', 'quantity_in_stock',
        'reorder_level', 'reorder_quantity', 'critical_level'
    )

def calculate_critical_stock_count(low_stock_items):
    return low_stock_items.filter(
        quantity_in_stock__lt=F('critical_level')
    ).count()

def calculate_total_products():
    return Product.objects.count()

def calculate_average_reorder_quantity():
    return Product.objects.aggregate(
        avg_reorder=ExpressionWrapper(
            Sum('reorder_quantity'),
            output_field=FloatField()
        )
    )['avg_reorder'] or 0.0

def calculate_category_data(total_inventory_value):
    return Category.objects.annotate(
        product_count=Count('product'),
        batch_count=Count('product__productbatch'),
        total_quantity=Sum('product__productbatch__initial_quantity'),
        total_value=Sum(
            ExpressionWrapper(
                F('product__productbatch__initial_quantity') * F('product__productbatch__buying_price'),
                output_field=FloatField()
            )
        ),
        percentage=ExpressionWrapper(
            Sum(
                ExpressionWrapper(
                    F('product__productbatch__initial_quantity') * F('product__productbatch__buying_price'),
                    output_field=FloatField()
                )
            ) * 100.0 / (total_inventory_value if total_inventory_value else 1),
            output_field=FloatField()
        )
    ).values(
        'id', 'name', 'product_count', 'batch_count',
        'total_quantity', 'total_value', 'percentage'
    ).order_by('-total_value')

def process_category_data(category_data):
    return [
        {
            'id': item['id'],
            'name': item['name'],
            'product_count': item['product_count'],
            'batch_count': item['batch_count'],
            'total_quantity': item['total_quantity'] or 0,
            'total_value': item['total_value'] or 0.0,
            'percentage': item['percentage'] or 0.0
        }
        for item in category_data
    ]

def calculate_inventory_trend(today, twelve_months_ago):
    inventory_trend = ProductBatch.objects.filter(
        stock_date__gte=twelve_months_ago
    ).annotate(
        month=TruncMonth('stock_date')
    ).values('month').annotate(
        total_value=Sum(
            ExpressionWrapper(
                F('initial_quantity') * F('buying_price'),
                output_field=FloatField()
            )
        )
    ).order_by('month')

    labels, values = [], []
    current_month = twelve_months_ago.replace(day=1)
    while current_month <= today:
        month_data = next(
            (item for item in inventory_trend if item['month'] and item['month'].month == current_month.month and item['month'].year == current_month.year),
            {'total_value': 0.0}
        )
        labels.append(current_month.strftime('%b %Y'))
        values.append(float(month_data['total_value'] or 0.0))
        current_month = (current_month + timezone.timedelta(days=32)).replace(day=1)
    return labels, values

def get_recent_orders(thirty_days_ago):
    return Order.objects.filter(
        order_date__gte=thirty_days_ago,
        payment_method__in=["cash", "credit_card", "mobile_money", "bank_transfer"]
    )

def calculate_total_revenue(orders):
    return orders.aggregate(
        total=Sum('total_price', output_field=FloatField())
    )['total'] or 0.0

def get_previous_period_orders(thirty_days_ago):
    previous_period_start = thirty_days_ago - timezone.timedelta(days=30)
    return Order.objects.filter(
        order_date__gte=previous_period_start,
        order_date__lt=thirty_days_ago,
        payment_method__in=["cash", "credit_card", "mobile_money", "bank_transfer"]
    )

def calculate_previous_revenue(previous_period_orders):
    return previous_period_orders.aggregate(
        total=Sum('total_price', output_field=FloatField())
    )['total'] or 0.0

def calculate_revenue_growth(total_revenue, previous_revenue):
    return ((total_revenue - previous_revenue) / previous_revenue * 100) if previous_revenue else 0.0

def calculate_cogs_and_gross_profit( total_revenue, orders, buying_price_subquery):
    total_cogs = orders.annotate(
        buying_price=buying_price_subquery
    ).aggregate(
        total_cost=Sum(
            ExpressionWrapper(
                F('quantity') * F('buying_price'),
                output_field=FloatField()
            )
        )
    )['total_cost'] or 0.0
    gross_profit = total_revenue - total_cogs
    gross_margin = (gross_profit / total_revenue * 100) if total_revenue else 0.0
    return total_cogs, gross_profit, gross_margin

def calculate_total_orders(orders):
    return orders.count()

def calculate_avg_order_value(total_revenue, total_orders):
    return (total_revenue / total_orders) if total_orders else 0.0

def get_top_selling_products(orders, buying_price_subquery):
    try:
        top_selling = orders.annotate(
            buying_price=buying_price_subquery
        ).values(
            'product__name', 'product__category__name'
        ).annotate(
            qty=Sum('quantity'),
            revenue=Sum('total_price', output_field=FloatField()),
            cost=Sum(
                ExpressionWrapper(
                    F('quantity') * F('buying_price'),
                    output_field=FloatField()
                )
            )
        ).annotate(
            profit=ExpressionWrapper(
                F('revenue') - F('cost'),
                output_field=FloatField()
            ),
            margin=ExpressionWrapper(
                (F('revenue') - F('cost')) / F('revenue') * 100,
                output_field=FloatField()
            )
        ).order_by('-revenue')[:10]

        logger.debug("Top Selling Raw: %s", list(top_selling))

        processed_top_selling = [
            {
                'product__name': item['product__name'],
                'product__category__name': item['product__category__name'],
                'qty': item['qty'] or 0,
                'revenue': item['revenue'] or 0.0,
                'cost': item['cost'] or 0.0,
                'profit': item['profit'] or 0.0,
                'margin': item['margin'] or 0.0 if item['revenue'] else 0.0
            }
            for item in top_selling
        ]

        logger.debug("Top Selling Processed: %s", processed_top_selling)
        return processed_top_selling
    except Exception as e:
        logger.error("Error in top_selling query: %s", str(e))
        return []

def calculate_top_selling_metrics(processed_top_selling, total_revenue):
    top5_revenue = sum(item['revenue'] for item in processed_top_selling[:5] if item['revenue'] is not None) or 0.0
    top5_percentage = (top5_revenue / total_revenue * 100) if total_revenue else 0.0
    other_percentage = 100.0 - top5_percentage if total_revenue else 0.0
    top_product_names = [item['product__name'] for item in processed_top_selling]
    top_product_values = [item['revenue'] for item in processed_top_selling]
    return top5_revenue, top5_percentage, other_percentage, top_product_names, top_product_values

def calculate_monthly_sales(today, twelve_months_ago, orders, buying_price_subquery):
    monthly_sales = orders.annotate(
        month=TruncMonth('order_date'),
        buying_price=buying_price_subquery
    ).values('month').annotate(
        total_sales=Sum('total_price', output_field=FloatField()),
        order_count=Count('id'),
        cogs=Sum(
            ExpressionWrapper(
                F('quantity') * F('buying_price'),
                output_field=FloatField()
            )
        )
    ).annotate(
        net_sales=F('total_sales'),
        gross_profit=ExpressionWrapper(
            F('total_sales') - F('cogs'),
            output_field=FloatField()
        ),
        margin=ExpressionWrapper(
            (F('total_sales') - F('cogs')) / F('total_sales') * 100,
            output_field=FloatField()
        )
    ).order_by('month')

    processed_monthly_sales = [
        {
            'month': item['month'],
            'total_sales': item['total_sales'] or 0.0,
            'order_count': item['order_count'],
            'cogs': item['cogs'] or 0.0,
            'net_sales': item['net_sales'] or 0.0,
            'gross_profit': item['gross_profit'] or 0.0,
            'margin': item['margin'] or 0.0 if item['total_sales'] else 0.0
        }
        for item in monthly_sales
    ]

    labels, sales_data, profit_data = [], [], []
    current_month = twelve_months_ago.replace(day=1)
    while current_month <= today:
        month_data = next(
            (item for item in processed_monthly_sales if item['month'] and item['month'].month == current_month.month and item['month'].year == current_month.year),
            {
                'total_sales': 0.0,
                'gross_profit': 0.0,
                'order_count': 0,
                'net_sales': 0.0,
                'cogs': 0.0,
                'margin': 0.0
            }
        )
        labels.append(current_month.strftime('%b %Y'))
        sales_data.append(float(month_data['total_sales']))
        profit_data.append(float(month_data['gross_profit']))
        current_month = (current_month + timezone.timedelta(days=32)).replace(day=1)
    return labels, sales_data, profit_data

def calculate_sales_trend(total_revenue, previous_revenue, total_cogs, total_orders, previous_period_orders):
    current_period_sales = total_revenue
    previous_period_sales = previous_revenue
    sales_change = calculate_revenue_growth(total_revenue, previous_revenue)
    current_period_units = total_orders
    previous_period_units = previous_period_orders.aggregate(total=Sum('quantity'))['total'] or 0
    units_change = ((current_period_units - previous_period_units) / previous_period_units * 100) if previous_period_units else 0.0
    current_avg_order = calculate_avg_order_value(total_revenue, total_orders)
    previous_avg_order = (previous_revenue / previous_period_orders.count()) if previous_period_orders.count() else 0.0
    aov_change = ((current_avg_order - previous_avg_order) / previous_avg_order * 100) if previous_avg_order else 0.0
    return current_period_sales, previous_period_sales, sales_change, current_period_units, previous_period_units, units_change, current_avg_order, previous_avg_order, aov_change

def calculate_daily_sales(orders, buying_price_subquery):
    return orders.annotate(
        buying_price=buying_price_subquery
    ).values(
        'order_date', 'id', 'product__name', 'quantity', 'total_price'
    ).annotate(
        date=F('order_date'),
        order_id=F('id'),
        product=F('product__name'),
        unit_price=ExpressionWrapper(
            F('total_price') / F('quantity'),
            output_field=FloatField()
        ),
        cost=ExpressionWrapper(
            F('quantity') * F('buying_price'),
            output_field=FloatField()
        ),
        revenue=F('total_price'),
        profit=ExpressionWrapper(
            F('total_price') - F('cost'),
            output_field=FloatField()
        )
    ).order_by('-order_date')

def calculate_total_units(orders):
    return orders.aggregate(total=Sum('quantity'))['total'] or 0

def calculate_profitability_matrix(orders, buying_price_subquery):
    return orders.annotate(
        buying_price=buying_price_subquery
    ).values(
        'product__name'
    ).annotate(
        revenue=Sum('total_price', output_field=FloatField()),
        cogs=Sum(
            ExpressionWrapper(
                F('quantity') * F('buying_price'),
                output_field=FloatField()
            )
        ),
        volume=Sum('quantity')
    ).annotate(
        profit=ExpressionWrapper(
            F('revenue') - F('cogs'),
            output_field=FloatField()
        ),
        margin=ExpressionWrapper(
            (F('revenue') - F('cogs')) / F('revenue') * 100,
            output_field=FloatField()
        ),
        contribution=ExpressionWrapper(
            (F('revenue') - F('cogs')) * 100 /
            Case(
                When(cogs=0, then=Value(1)),
                default=F('cogs'),
                output_field=FloatField()
            ),
            output_field=FloatField()
        )
    ).order_by('-profit')

def calculate_category_profit(orders, buying_price_subquery):
    category_profit = orders.annotate(
        buying_price=buying_price_subquery
    ).values(
        'product__category__name'
    ).annotate(
        revenue=Sum('total_price', output_field=FloatField()),
        cogs=Sum(
            ExpressionWrapper(
                F('quantity') * F('buying_price'),
                output_field=FloatField()
            )
        )
    ).annotate(
        profit=ExpressionWrapper(
            F('revenue') - F('cogs'),
            output_field=FloatField()
        ),
        margin=ExpressionWrapper(
            (F('revenue') - F('cogs')) / F('revenue') * 100,
            output_field=FloatField()
        )
    ).order_by('-profit')

    return [
        {
            'product__category__name': item['product__category__name'],
            'revenue': item['revenue'] or 0.0,
            'cogs': item['cogs'] or 0.0,
            'profit': item['profit'] or 0.0,
            'margin': item['margin'] or 0.0 if item['revenue'] else 0.0
        }
        for item in category_profit
    ]

def get_near_expiry_products(today):
    return ProductBatch.objects.filter(
        expiry_date__range=[today, today + timezone.timedelta(days=365)]
    ).select_related('product').values(
        'product__name', 'expiry_date', 'initial_quantity'
    ).order_by('expiry_date')


def report_analysis(request):
    today = timezone.now().date()
    thirty_days_ago = today - timezone.timedelta(days=30)
    twelve_months_ago = today - timezone.timedelta(days=365)

    buying_price_subquery = get_latest_buying_price_subquery()
    batch_values = calculate_batch_values()
    total_inventory_value = calculate_total_inventory_value(batch_values)
    inventory_data = process_inventory_data(batch_values, total_inventory_value)

    low_stock_items = get_low_stock_items()
    critical_stock_count = calculate_critical_stock_count(low_stock_items)
    total_products = calculate_total_products()
    low_stock_count = low_stock_items.count()
    average_reorder_quantity = calculate_average_reorder_quantity()
    category_data = process_category_data(calculate_category_data(total_inventory_value))

    inventory_trend_labels, inventory_trend_values = calculate_inventory_trend(today, twelve_months_ago)

    orders = get_recent_orders(thirty_days_ago)
    total_revenue = calculate_total_revenue(orders)
    previous_period_orders = get_previous_period_orders(thirty_days_ago)
    previous_revenue = calculate_previous_revenue(previous_period_orders)
    revenue_growth = calculate_revenue_growth(total_revenue, previous_revenue)

    total_cogs, gross_profit, gross_margin = calculate_cogs_and_gross_profit(orders, buying_price_subquery)
    total_orders = calculate_total_orders(orders)
    avg_order_value = calculate_avg_order_value(total_revenue, total_orders)

    top_selling_processed = get_top_selling_products(orders, buying_price_subquery)
    top5_revenue, top5_percentage, other_percentage, top_product_names, top_product_values = calculate_top_selling_metrics(top_selling_processed, total_revenue)

    monthly_labels, monthly_sales_data, monthly_profit_data = calculate_monthly_sales(today, twelve_months_ago, orders, buying_price_subquery)

    current_period_sales, previous_period_sales, sales_change, current_period_units, previous_period_units, units_change, current_avg_order, previous_avg_order, aov_change = calculate_sales_trend(total_revenue, previous_revenue, total_cogs, total_orders, previous_period_orders)

    daily_sales = calculate_daily_sales(orders, buying_price_subquery)
    total_units = calculate_total_units(orders)
    total_cost = total_cogs
    total_profit = gross_profit

    profitability_matrix = calculate_profitability_matrix(orders, buying_price_subquery)
    category_profit = calculate_category_profit(orders, buying_price_subquery)
    near_expiry = get_near_expiry_products(today)

    context = {
        'total_revenue': total_revenue,
        'revenue_growth': round(revenue_growth, 2),
        'gross_profit': gross_profit,
        'gross_margin': round(gross_margin, 2),
        'avg_order_value': avg_order_value,
        'total_orders': total_orders,
        'return_rate': 0.0, 
        'total_returns': 0.0,
        'default_start_date': thirty_days_ago,
        'default_end_date': today,
        'total_inventory_value': total_inventory_value,
        'total_sales': total_revenue,
        'low_stock_count': low_stock_count,
        'critical_stock_count': critical_stock_count,
        'expiring_soon_count': near_expiry.count(),
        'inventory': inventory_data,
        'inventory_trend_labels': json.dumps(inventory_trend_labels),
        'inventory_trend_values': inventory_trend_values,
        'low_stock_items': low_stock_items,
        'total_products': total_products,
        'average_reorder_quantity': round(average_reorder_quantity),
        'category': category_data,
        'category_names': json.dumps([cat['name'] for cat in category_data]),
        'category_values': [cat['total_value'] for cat in category_data],
        'top_selling': top_selling_processed,
        'top_product_names': json.dumps(top_product_names),
        'top_product_values': top_product_values,
        'top5_percentage': round(top5_percentage, 2),
        'other_percentage': round(other_percentage, 2),
        'monthly_sales': monthly_sales_data,
        'monthly_labels': json.dumps(monthly_labels),
        'monthly_profit_data': monthly_profit_data,
        'current_period_sales': current_period_sales,
        'previous_period_sales': previous_period_sales,
        'sales_change': round(sales_change, 2),
        'current_period_units': current_period_units,
        'previous_period_units': previous_period_units,
        'units_change': round(units_change, 2),
        'current_avg_order': current_avg_order,
        'previous_avg_order': previous_avg_order,
        'aov_change': round(aov_change, 2),
        'daily_sales': daily_sales,
        'total_units': total_units,
        'total_cost': total_cost,
        'total_profit': total_profit,
        'profitability_matrix': profitability_matrix,
        'category_profit': category_profit,
        'near_expiry': near_expiry,
        'current_date': today.strftime("%Y-%m-%d"),
        'report_range': f"{thirty_days_ago.strftime('%b %d')} - {today.strftime('%b %d')}"
    }

    return render(request, 'InvApp/report_analysis.html', context)
    
# def product_list(request):
#     categories, product_batches = get_categories_and_product_batches()
#     category_id = request.GET.get('category', '')
#     page_number = request.GET.get('page')
#     # Filter products
#     products = Product.objects.all().order_by('-product_id')
#     if category_id:
#         products = products.filter(category_id=category_id)

#     # Paginate
#     paginator = Paginator(products, 10)
#     page_obj = paginator.get_page(page_number)

#     # Initialize form (bound on POST, unbound otherwise)
#     form = ProductForm(request.POST or None)

#     # Handle form submission
#     if request.method == 'POST':
#         if form.is_valid():
#             form.save()
#             product_name = form.cleaned_data['name']
#             messages.success(request, f"Product '{product_name}' created successfully!")
            
#             # Preserve query parameters in redirect
#             redirect_url = reverse('product_list')
#             if category_id:
#                 redirect_url += f'?category={category_id}'
#                 if page_number:
#                     redirect_url += f'&page={page_number}'
#             return redirect(redirect_url)
        
#     # Handle AJAX request (e.g., pagination)
#     if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
#         return handle_ajax_request(page_obj, paginator)

#     context = {
#         'page_obj': page_obj,
#         'categories': categories,
#         'category_id': category_id,
#         'product_batches': product_batches,
#         'form': form
#     }
#     return render(request, 'InvApp/product_list.html', context)

